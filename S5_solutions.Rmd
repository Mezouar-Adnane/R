---
title: "Shiny exercises: beginner level"
output: html_notebook
---

First things first: activation of packages + load the data.

```{r}
library(tidyverse)        # Just to be sure it's the first thing that is done...
library(shiny)
library(shinydashboard)
library(DT)
library(plotly)

load("songs.RData")
load("movies.RData")
```


# Songs dataset: exercises

A simple dashboard is given below:

```{r}
ui <- dashboardPage(                                                   # FULL PAGE: don't touch!
    dashboardHeader(title = "Songs Dashboard"),                        # Header zone
    dashboardSidebar(sliderInput("pop", h4("Popularity"),              
                                 min = 0, max = 100,                      
                                 value = c(0, 100), step = 1, sep = ""),
                     sliderInput("energy", h4("Energy"),                
                                 min = 0, max = 1,
                                 value = c(0,1), step = 0.1, sep = "")
    ),        
    dashboardBody(plotOutput("plot"),                                  # Body
                  dataTableOutput("table")
    )                            
)  

server <- function(input, output){                                     # Server: computations!
    data <- reactive(
        songs %>% filter(popularity >= input$pop[1],
                         popularity <= input$pop[2],
                         energy >= input$energy[1],
                         energy <= input$energy[2])
    )
    output$table <- renderDataTable(data())         
    
    output$plot <- renderPlot({
        data() %>% ggplot(aes(x = energy, y = popularity, color = speechiness)) + geom_point() + xlim(0,1)
    })
}

# Run the app ----
shinyApp(ui = ui, server = server)  # Aggregates the app.
```

**1**. In the body, separate the two outputs (plot and table) and put each one of them in two separate tabs (one for the graph, one for the table). Also, transform the simple plot into a *plotly* graph. You can: increase the plot height and also change the size of the points (they are too big in plotly).


```{r}
ui <- dashboardPage(                                                    # FULL PAGE: don't touch!
    dashboardHeader(title = "Songs Dashboard"),                         # Header zone
    dashboardSidebar(sliderInput("pop", h4("Popularity"),              
                                 min = 0, max = 100,                      
                                 value = c(0, 100), step = 1, sep = ""),
                     sliderInput("energy", h4("Energy"),                # Energy widget
                                 min = 0, max = 1,
                                 value = c(0,1), step = 0.1, sep = "")
    ),        
    dashboardBody(
        tabBox(
            title = "Results", height = "920px", width = 12,
            tabPanel("Plot", 
                     plotlyOutput("plot", height = 600)),               # Plotly!
            tabPanel("Table", 
                     DT::dataTableOutput("table"))
        )
    )
)                            


server <- function(input, output){                                      # Server: computations!
    data <- reactive(
        songs %>% filter(popularity >= input$pop[1],
                         popularity <= input$pop[2],
                         energy >= input$energy[1],
                         energy <= input$energy[2])
    )
    output$table <- renderDataTable(data())         
    
    output$plot <- renderPlotly({                                       # Plotly!
        data() %>% ggplot(aes(x = energy, y = popularity, 
                              label = artist, color = speechiness)) + geom_point(size = 0.3) + xlim(0,1)
    })
}

# Run the app ----
shinyApp(ui = ui, server = server)  # Aggregates the app.
```


**2**. Boxes & rows & columns!    
a) Within the tabBox of the body, add a new tabPanel (& choose a name).       
b) In the server, create a new valueBox that counts the number of songs after the filter. You can find an icon if you want.    
c) In the body and inside the new tab you created, insert the valueBox.     
d) In the server, create a new infoBox that computes the average popularity of the songs after the filter.   
e) In the body, insert a fluidRow. In this fluidRow, insert two columns (choose the widths you prefer) and inside each column, include the valueBox & infoBox generated by the server.   


```{r}
ui <- dashboardPage(                                                    # FULL PAGE: don't touch!
    dashboardHeader(title = "Songs Dashboard"),                         # Header zone
    dashboardSidebar(sliderInput("pop", h4("Popularity"),              
                                 min = 0, max = 100,                      
                                 value = c(0, 100), step = 1, sep = ""),
                     sliderInput("energy", h4("Energy"),                
                                 min = 0, max = 1,
                                 value = c(0,1), step = 0.1, sep = "")
    ),        
    dashboardBody(
        tabBox(
            title = "Results", height = "920px", width = 12,
            tabPanel("Plot", 
                     plotlyOutput("plot", height = 600)),
            tabPanel("Table", 
                     DT::dataTableOutput("table")),
            tabPanel("Boxes",                                             # a) 
                     fluidRow(                                            # e)
                         column(5,valueBoxOutput("box1", width = 12)),    # e) and c)
                         column(7,infoBoxOutput("box2", width = 12))      # e) 
                     )
            )
        )
    )
)                            


server <- function(input, output){                                        # Server: computations!
    data <- reactive(
        songs %>% filter(popularity >= input$pop[1],
                         popularity <= input$pop[2],
                         energy >= input$energy[1],
                         energy <= input$energy[2])
    )
    output$table <- renderDataTable(data())         
    
    output$plot <- renderPlotly({
        data() %>% ggplot(aes(x = energy, y = popularity, 
                              label = artist, color = speechiness)) + geom_point(size = 0.3) + xlim(0,1)
    })
    
    output$box1 <- renderValueBox({                                      # b)
        valueBox(
            value = nrow(data()), 
            subtitle =  "Number of songs",
            icon = icon("music", lib = "font-awesome"),
            color = "blue",
            width = 4  # Width in Bootstrap mode: needs a column()!
        )
    })
    
    output$box2 <- renderInfoBox({                                       # d)
        temp_data <- data()
        infoBox(
            value = mean(temp_data$popularity) %>% round(2), # Rounding the number
            title = "Popularity", 
            subtitle = "(average)", 
            icon = icon("star", lib = "font-awesome"),
            color = "red"
        )
    })
}

# Run the app ----
shinyApp(ui = ui, server = server)  # Aggregates the app.
```


# Movies dataset

A simple dashboard is given below.

```{r}
ui <- dashboardPage(                                                   # FULL PAGE: don't touch!
    dashboardHeader(title = "Movies Dashboard"),                       # Header zone
    dashboardSidebar(sliderInput("duration", h4("Duration (min)"),     
                                 min = 37, max = 330,                      
                                 value = c(37, 330), step = 1, sep = ""),
                     checkboxGroupInput("color", h4("Color"),                                 
                                        choices = list("Color" = "Color", 
                                                       "Black and White" = "Black and White"), 
                                        selected = c("Color", "BW"))),         
    dashboardBody(plotOutput("plot"),                                   
                  dataTableOutput("table"))                            
)  

server <- function(input, output){                                     # Server: computations!
    data <- reactive(                                                  # Reactive data!
        movies %>% filter(duration >= input$duration[1],               
                          duration <= input$duration[2],               
                          color %in% input$color)                      
    )
    output$table <- renderDataTable(data())                            # Reactive!
    output$plot <- renderPlot(                                         
        data() %>% group_by(year) %>% 
            summarise(avg_score = mean(imdb_score)) %>%
            ggplot(aes(x = year, y = avg_score)) + geom_line() + geom_point()
    )
}

# Run the app ----
shinyApp(ui = ui, server = server)  # Aggregates the app.
```

**1**. In the body, separate the two outputs via two tabs: one output in each tab. The table is a bit large: you can remove the actors' names from the output. Transform plot into plotly.

```{r}
ui <- dashboardPage(                                                   # FULL PAGE: don't touch!
    dashboardHeader(title = "Movies Dashboard"),                       # Header zone
    dashboardSidebar(sliderInput("duration", h4("Duration (min)"),      
                                 min = 37, max = 330,                      
                                 value = c(37, 330), step = 1, sep = ""),
                     checkboxGroupInput("color", h4("Color"),                                  
                                        choices = list("Color" = "Color", 
                                                       "Black and White" = "Black and White"), 
                                        selected = c("Color", "BW"))),         
    dashboardBody(
        tabBox(width = 12,                                             # Full width
               tabPanel("Plot", width = 12, 
                        plotlyOutput("plot")),                                   
               tabPanel("Table", width = 12, dataTableOutput("table"))
        )                            
    )
)  

server <- function(input, output){                                     # Server: computations!
    data <- reactive(                                                  # Reactive data!
        movies %>% filter(duration >= input$duration[1],               
                          duration <= input$duration[2],               
                          color %in% input$color) %>%
            select(-actor_1, -actor_2, -actor_3)                       # Take out actor information! BEWARE: at the source level!
    )
    output$table <- renderDataTable(data())                            # Reactive! Actor info could be removed here (better?).
    output$plot <- renderPlotly(                                         
        data() %>% group_by(year) %>% 
            summarise(avg_score = mean(imdb_score)) %>%
            ggplot(aes(x = year, y = avg_score)) + geom_line() + geom_point()
    )
}

# Run the app ----
shinyApp(ui = ui, server = server)  # Aggregates the app.
```

**2**. Create two boxes
a) In the body, inside the first tabPanel, on top of the graph, add a fluidRow. (you can change the title of the tab later on)   
b) Split this fluidRow into two components (columns).  
c) In the server, create a value box that displays the movie with the highest IMDB score (along with this rating). Technical note: it should be unique. If conflict because several movies have max rating, pick one.
d) Likewise, create an info box that computes the average budget (post filter: reactive) of the movies. Use a nice icon!
e) Integrate the boxes into the fluidRow defined in a).


```{r}
ui <- dashboardPage(                                                   # FULL PAGE: don't touch!
    dashboardHeader(title = "Movies Dashboard"),                       # Header zone
    dashboardSidebar(sliderInput("duration", h4("Duration (min)"),      
                                 min = 37, max = 330,                      
                                 value = c(37, 330), step = 1, sep = ""),
                     checkboxGroupInput("color", h4("Color"),                                  
                                        choices = list("Color" = "Color", 
                                                       "Black and White" = "Black and White"), 
                                        selected = c("Color", "BW"))),         
    dashboardBody(
        tabBox(width = 12,                                                   # Full width
               tabPanel("Ranking & Plot", width = 12,                        # a)
                        fluidRow(                                            # a)
                            column(4,valueBoxOutput("box1", width = 12)),    # b) & e) 
                            column(8,infoBoxOutput("box2", width = 12))      # b) & e) 
                        ),
                        plotlyOutput("plot")),                                   
               tabPanel("Table", width = 12, dataTableOutput("table"))
        )                            
    )
)  

server <- function(input, output){                                     # Server: computations!
    data <- reactive(                                                  # Reactive data!
        movies %>% filter(duration >= input$duration[1],               
                          duration <= input$duration[2],               
                          color %in% input$color) %>%
            select(-actor_1, -actor_2, -actor_3)                       # Take out actor information! BEWARE: at the source level!
    )
    output$table <- renderDataTable(data())                            # Reactive! Actor info could be removed here (better?).
    output$plot <- renderPlotly(                                         
        data() %>% group_by(year) %>% 
            summarise(avg_score = mean(imdb_score)) %>%
            ggplot(aes(x = year, y = avg_score)) + geom_line() + geom_point()
    )
    
    output$box1 <- renderValueBox({                                      # c)
        valueBox(
            value = mean(data()$budget) %>% round(), 
            subtitle =  "Average budget (M$)",
            icon = icon("dollar", lib = "font-awesome"),
            color = "blue",
            width = 4  # Width in Bootstrap mode: needs a column()!
        )
    })
    
    output$box2 <- renderInfoBox({                                       # d)
        temp_data <- data()
        infoBox(
            value = max(data()$imdb_score), # Rounding the number
            title = "Best movie", 
            # Classical tidyverse below but conflicts if not unique
            # subtitle = filter(data(), imdb_score == max(imdb_score)) %>% select(title), 
            subtitle = data()[which(data()$imdb_score == max(data()$imdb_score))[1],]$title, # That's a bit harsh...
            icon = icon("star", lib = "font-awesome"),
            color = "red"
        )
    })
}

# Run the app ----
shinyApp(ui = ui, server = server)  # Aggregates the app.
```


